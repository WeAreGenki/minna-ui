<!--
  INPUT SELECT COMPONENT

  A custom form input component similar to a native <select> element. Allows the
  user to select from a list of shown options.

  Features:
    - Automatically opens on focus for faster form input when using a keyboard
      for navigating.
    - User can filter through options with instant visual feedback.

  USAGE:
    HTML markup for typical use:

      <Select id="select-example" bind:value="example" items="[
        { id: 'ex1', text: 'Example 1' },
        { id: 'ex2', text: 'Example 2' },
        { id: 'ex3', text: 'Example 3', disabled: true },
      ]"/>

    See more available options/properties in the component data() below.

  NOTE:
    In the code, object properties starting with _ are safe to mangle; the name
    can be shortened at build time for smaller JavaScript bundles.

  REFERENCE:
    - https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/#Listbox
    - https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/listbox/listbox-collapsible.html

-->

<!-- TODO: Incorporate WAI-ARIA recommendations (once svelte can handle custom boolean attributes) -->

<!-- TODO: Explore moving the viewport when using keyboard navigation and the option is off-screen -->

<div class="pos-r dif f-col{disabled ? ' select-disabled' : ''}{_isOpen ? ' select-active' : ''}">
  <!-- TODO: Could the input be replaced with a div+contentEditable? Would it have any extra value? -->
  <input
    id="{id}"
    ref:_target
    bind:value="_inputText"
    class="select"
    tabindex="{disabled ? -1 : 0}"
    placeholder="{filterable && _isOpen ? filterHelp : placeholder}"
    readonly="{!filterable || readonly || !_isOpen}"
    disabled="{disabled}"
    aria-haspopup="listbox"
    on:click="_open()"
    on:focus="_open()"
    on:blur="_close()"
    on:keydown="_onKeyDown(event)"
  >
  <div class="select-caret"/>

  <div
    class="select-listbox{_isOpen ? '' : ' hide'}"
    role="listbox"
    on:mousedown="_select(event)"
  >
    {#each _filteredItems as _item, _index}
      <div
        class="option{_item.disabled ? ' option-disabled' : ''}{_index === _selected ? ' option-active' : ''}"
        value="{_item.id}"
        role="option"
      >
        {_item.text}
      </div>
    {:else}
      <div class="pa3 gray">
        No matches
      </div>
    {/each}
  </div>
</div>

<script>
  export default {
    data: () => ({
      _isOpen: false,
      _inputText: '',
      _selected: 0, // index of the currently selected item

      /* required bind prop */
      // value: '',

      /* required props */
      // id: '',
      // items: [], // `options` is already defined on Svelte instances

      /* optional props */
      filterable: true,
      filterHelp: 'Filter...',
      placeholder: 'Choose...',

      /* optional native props */
      readonly: false,
      disabled: false,
      // required: false, // FIXME: Add a way to do custom validation
    }),
    computed: {
      _filteredItems({ _isOpen, _inputText, filterable, items }) {
        if (!_isOpen || !filterable || _inputText === '') return items;

        return items.filter(
          option => option.text.toLowerCase().indexOf(_inputText.toLowerCase()) > -1
        );
      },
    },
    onstate({ changed, current }) {
      if (changed._filteredItems) {
        this._setIndex();
      }

      if (changed.value && current.value) {
        this._setInput();
      }
    },
    methods: {
      _setIndex() {
        const { _filteredItems, value } = this.get();

        if (value) {
          // save the current item's index for highlighting in the options
          this.set({
            _selected: _filteredItems.findIndex(option => option.id === value),
          });
        }
      },

      _setInput() {
        const { items, value } = this.get();

        this.set({
          _inputText: value
            ? items.find(option => option.id === value).text
            : '',
        });
      },

      _open() {
        this._setIndex();

        // FIXME: Don't call this.set() twice because svelte doesn't queue changes
        /* istanbul ignore else */
        if (this.get().filterable) {
          this.set({ _inputText: '' });
        }
        this.set({ _isOpen: true });
      },

      _close() {
        this.set({ _isOpen: false });
        this._setInput();
      },

      _emitInput() {
        // fire a synthetic "input" event (useful to trigger validation)
        this.refs._target.dispatchEvent(new KeyboardEvent('input', { bubbles: true }));
        this._close();
      },

      _select(event) {
        if (event) {
          // option selected via mouse
          event.preventDefault(); // don't trigger <input> blur event

          if (!event.target.classList.contains('option-disabled')) {
            this.set({
              value: event.target.getAttribute('value'),
              _inputText: event.target.textContent,
            });
            this._emitInput();
          }
        } else {
          // option selected via keyboard
          const { _filteredItems, _selected } = this.get();
          const option = _filteredItems[_selected];

          /* istanbul ignore else */
          if (!option.disabled) {
            this.set({
              value: option.id,
              _inputText: option.text,
            });
            this._emitInput();
          }
        }
      },

      _up() {
        const { _selected, _filteredItems } = this.get();

        if (_selected <= 0) return;

        let steps = 1;

        // skip over disabled items or if there's no items left
        while (_filteredItems[_selected - steps].disabled) {
          steps += 1;
          if (_filteredItems[_selected - steps] === undefined) return;
        }

        this.set({ _selected: _selected - steps });
      },

      _down() {
        const { _selected, _filteredItems } = this.get();

        // jump to last availiable item if index is out of bounds (e,g, after filtering)
        if (_selected >= _filteredItems.length - 1) {
          this.set({ _selected: _filteredItems.length - 1 });
          return;
        }

        let steps = 1;

        // skip over disabled items or if there's no items left
        while (_filteredItems[_selected + steps].disabled) {
          steps += 1;
          if (_filteredItems[_selected + steps] === undefined) return;
        }

        this.set({ _selected: _selected + steps });
      },

      _onKeyDown(event) {
        const { _isOpen } = this.get();

        // choose key with graceful fallback for old browsers
        switch (event.key || event.keyCode) {
          case ' ':
          case 'Spacebar':
          case 32:
            if (!_isOpen) {
              this._open();
            }
            break;
          case 'Enter':
          case 13:
            event.preventDefault(); // don't submit form
            if (_isOpen) {
              this._select();
            } else {
              this._open();
            }
            break;
          case 'Escape':
          case 27:
            this._close();
            break;
          case 'ArrowUp':
          case 'Up':
          case 38:
            event.preventDefault(); // don't scroll page or move cursor
            if (_isOpen) {
              this._up();
            } else {
              this._open();
            }
            break;
          case 'ArrowDown':
          case 'Down':
          case 40:
            event.preventDefault(); // don't scroll page or move cursor
            if (_isOpen) {
              this._down();
            } else {
              this._open();
            }
            break;
          default:
            // no matching key
        }
      },
    },
  };
</script>

<style type="text/postcss">
  @import "./_variables.css";
  @import "import.css";

  .hide {
    pointer-events: none;
    opacity: 0;
  }

  .select {
    .select-active > & {
      cursor: auto;
    }
  }

  .select-caret {
    position: absolute;
    top: calc(50% - ($select-caret-size / 2));
    right: 0.75em;
    pointer-events: none;

    @include draw-triangle($select-caret-size, $select-caret-color);

    @if $select-optimize {
      will-change: transform;
    }

    .select-active > & {
      transform: scaleY(-1);
    }

    .select-disabled > & {
      border-top-color: $select-disabled-caret-color;
    }
  }

  .select-listbox {
    position: absolute;
    top: 100%;
    left: 0;
    z-index: $select-zindex;
    width: 100%;
    padding: $input-padding-y 0;
    font-size: $input-text-size;
    color: $input-text-color;
    text-align: left;
    background-color: $input-background-color;
    box-shadow: $select-shadow;
    transition:
      transform $select-animate-speed-out ease-out,
      opacity $select-animate-speed-out ease-out;
    backface-visibility: hidden; /* promote to own layer to avoid repaints */

    @if $select-optimize {
      will-change: transform, opacity;
    }

    &.hide {
      transition-duration: $select-animate-speed-in;
      transform: translateY(-1rem);
    }

    /* don't render when disabled for better performance */
    .select-disabled > & {
      display: none;

      @if $select-optimize {
        will-change: auto;
      }
    }
  }

  .option {
    padding: $input-padding-y $input-padding-x;
  }

  .option-active,
  .option:hover {
    color: $select-selected-text-color;
    background-color: $select-selected-background-color;
  }

  .option-disabled,
  .option-disabled:hover {
    color: $select-disabled-text-color;
    background-color: unset;
  }
</style>
